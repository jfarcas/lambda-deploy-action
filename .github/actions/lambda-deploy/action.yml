name: 'Generic Lambda Deploy'
description: 'Reusable action to deploy Lambda functions with flexible configuration. Requires environment variables: S3_BUCKET_NAME, LAMBDA_FUNCTION_NAME, AWS_REGION, and AWS credentials (AWS_ACCESS_KEY_ID + AWS_SECRET_ACCESS_KEY or AWS_ROLE_ARN).'

inputs:
  config-file:
    description: 'Path to the lambda deploy configuration file'
    required: false
    default: 'lambda-deploy-config.yml'
  environment:
    description: 'Environment to deploy to (dev, pre, prod, or auto for branch-based)'
    required: false
    default: 'auto'
  version:
    description: 'Version to deploy (overrides package.json version)'
    required: false
  force-deploy:
    description: 'Force deployment even if version already exists'
    required: false
    default: 'false'
  rollback-to-version:
    description: 'Version to rollback to (if specified, performs rollback instead of normal deployment)'
    required: false
  debug:
    description: 'Enable debug output for troubleshooting'
    required: false
    default: 'false'

outputs:
  deployed-version:
    description: 'Version that was deployed or rolled back to'
    value: ${{ steps.get-version.outputs.version || steps.retrieve-rollback.outputs.version }}
  deployment-environment:
    description: 'Environment where deployment occurred'
    value: ${{ steps.determine-env.outputs.environment }}
  lambda-version:
    description: 'Lambda function version number'
    value: ${{ steps.deploy-to-s3.outputs.lambda-version }}
  s3-location:
    description: 'S3 location of the deployment package'
    value: ${{ steps.deploy-to-s3.outputs.s3-location }}
  deployment-type:
    description: 'Type of deployment (deploy or rollback)'
    value: ${{ steps.deployment-mode.outputs.deployment-mode }}
  rollback-version:
    description: 'Version that was rolled back to (only for rollback deployments)'
    value: ${{ steps.retrieve-rollback.outputs.version }}

runs:
  using: "composite"
  steps:
    - name: Validate Environment Variables
      shell: bash
      run: |
        echo "ðŸ” Validating required environment variables..."
        
        # Optional debug output
        if [[ "${{ inputs.debug }}" == "true" ]]; then
          echo "ðŸ› DEBUG: Environment variables received by composite action:"
          echo "S3_BUCKET_NAME: '${S3_BUCKET_NAME:-NOT_SET}'"
          echo "LAMBDA_FUNCTION_NAME: '${LAMBDA_FUNCTION_NAME:-NOT_SET}'"
          echo "AWS_REGION: '${AWS_REGION:-NOT_SET}'"
          echo "AWS_ACCESS_KEY_ID: '${AWS_ACCESS_KEY_ID:+SET}'"
          echo "AWS_SECRET_ACCESS_KEY: '${AWS_SECRET_ACCESS_KEY:+SET}'"
          echo "AWS_ROLE_ARN: '${AWS_ROLE_ARN:+SET}'"
          echo "TEAMS_WEBHOOK_URL: '${TEAMS_WEBHOOK_URL:+SET}'"
        fi
        
        # Check required environment variables
        MISSING_VARS=()
        
        if [[ -z "$S3_BUCKET_NAME" ]]; then
          MISSING_VARS+=("S3_BUCKET_NAME")
        fi
        if [[ -z "$LAMBDA_FUNCTION_NAME" ]]; then
          MISSING_VARS+=("LAMBDA_FUNCTION_NAME")
        fi
        if [[ -z "$AWS_REGION" ]]; then
          MISSING_VARS+=("AWS_REGION")
        fi
        
        if [[ ${#MISSING_VARS[@]} -gt 0 ]]; then
          echo "::error::Missing required environment variables: ${MISSING_VARS[*]}"
          echo "::error::Please ensure these are set as repository variables or environment variables"
          echo "::error::And that they are passed to the action via the 'env:' block in your workflow"
          exit 1
        fi
        
        echo "âœ… All required environment variables are present"
        echo "S3_BUCKET_NAME: $S3_BUCKET_NAME"
        echo "LAMBDA_FUNCTION_NAME: $LAMBDA_FUNCTION_NAME"
        echo "AWS_REGION: $AWS_REGION"

    - name: Determine Deployment Mode
      id: deployment-mode
      shell: bash
      run: |
        if [[ -n "${{ inputs.rollback-to-version }}" ]]; then
          echo "ðŸ”„ Rollback mode detected"
          echo "deployment-mode=rollback" >> $GITHUB_OUTPUT
          echo "target-version=${{ inputs.rollback-to-version }}" >> $GITHUB_OUTPUT
          echo "DEPLOYMENT_MODE=rollback" >> $GITHUB_ENV
          echo "TARGET_VERSION=${{ inputs.rollback-to-version }}" >> $GITHUB_ENV
          
          # Validate rollback version format
          if [[ ! "${{ inputs.rollback-to-version }}" =~ ^v?[0-9]+\.[0-9]+\.[0-9]+.*$ ]]; then
            echo "::error::Invalid rollback version format: ${{ inputs.rollback-to-version }}"
            echo "::error::Expected format: v1.2.3 or 1.2.3"
            exit 1
          fi
          
          echo "ðŸŽ¯ Target rollback version: ${{ inputs.rollback-to-version }}"
        else
          echo "ðŸš€ Normal deployment mode"
          echo "deployment-mode=deploy" >> $GITHUB_OUTPUT
          echo "DEPLOYMENT_MODE=deploy" >> $GITHUB_ENV
        fi

    - name: Get Last Successful Version
      id: get-last-version
      if: steps.deployment-mode.outputs.deployment-mode == 'deploy'
      shell: bash
      run: |
        set -e
        
        echo "ðŸ” Getting last successful version for potential rollback..."
        
        # Check if auto-rollback is enabled
        CONFIG_FILE="${{ steps.load-config.outputs.config-file-path }}"
        AUTO_ROLLBACK_ENABLED=$(yq eval '.deployment.auto_rollback.enabled // false' "$CONFIG_FILE")
        
        if [[ "$AUTO_ROLLBACK_ENABLED" == "false" ]]; then
          echo "Auto-rollback is disabled, skipping last version lookup"
          echo "last-version=" >> $GITHUB_OUTPUT
          exit 0
        fi
        
        echo "Auto-rollback is enabled, looking up last successful version..."
        
        # Get current Lambda function configuration to find last successful version
        LAMBDA_FUNCTION="$LAMBDA_FUNCTION_NAME"
        
        # Try to get the current version from Lambda function tags
        ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
        FUNCTION_ARN="arn:aws:lambda:$AWS_REGION:$ACCOUNT_ID:function:$LAMBDA_FUNCTION"
        
        # Get current tags to find last successful deployment
        LAST_VERSION=""
        if aws lambda list-tags --resource "$FUNCTION_ARN" > /tmp/lambda-tags.json 2>/dev/null; then
          LAST_VERSION=$(jq -r '.Tags.Version // empty' /tmp/lambda-tags.json 2>/dev/null || echo "")
        fi
        
        if [[ -n "$LAST_VERSION" ]] && [[ "$LAST_VERSION" != "null" ]]; then
          echo "Found last successful version: $LAST_VERSION"
          echo "last-version=$LAST_VERSION" >> $GITHUB_OUTPUT
        else
          echo "No previous successful version found"
          echo "last-version=" >> $GITHUB_OUTPUT
        fi

    - name: Install yq for YAML parsing
      shell: bash
      run: |
        # Install yq for proper YAML parsing
        sudo wget -qO /usr/local/bin/yq https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64
        sudo chmod +x /usr/local/bin/yq
        yq --version

    - name: Load Configuration
      id: load-config
      shell: bash
      run: |
        set -e
        CONFIG_FILE="${{ inputs.config-file }}"
        
        # Validate config file exists
        if [[ ! -f "$CONFIG_FILE" ]]; then
          echo "::error::Configuration file $CONFIG_FILE not found"
          echo "Please ensure the configuration file exists in your repository root"
          exit 1
        fi
        
        # Validate YAML syntax
        if ! yq eval '.' "$CONFIG_FILE" > /dev/null 2>&1; then
          echo "::error::Invalid YAML syntax in $CONFIG_FILE"
          exit 1
        fi
        
        # Parse and validate required fields
        PROJECT_NAME=$(yq eval '.project.name' "$CONFIG_FILE")
        PROJECT_RUNTIME=$(yq eval '.project.runtime' "$CONFIG_FILE")
        
        if [[ "$PROJECT_NAME" == "null" || -z "$PROJECT_NAME" ]]; then
          echo "::error::Missing required field: project.name in $CONFIG_FILE"
          exit 1
        fi
        
        if [[ "$PROJECT_RUNTIME" == "null" || -z "$PROJECT_RUNTIME" ]]; then
          echo "::error::Missing required field: project.runtime in $CONFIG_FILE"
          exit 1
        fi
        
        # Validate runtime is supported
        if [[ ! "$PROJECT_RUNTIME" =~ ^(bun|node|python)$ ]]; then
          echo "::error::Unsupported runtime: $PROJECT_RUNTIME. Supported: bun, node, python"
          exit 1
        fi
        
        # Set outputs
        echo "config-loaded=true" >> $GITHUB_OUTPUT
        echo "project-name=$PROJECT_NAME" >> $GITHUB_OUTPUT
        echo "project-runtime=$PROJECT_RUNTIME" >> $GITHUB_OUTPUT
        echo "config-file-path=$CONFIG_FILE" >> $GITHUB_OUTPUT
        
        echo "âœ… Configuration loaded successfully:"
        echo "  - Project: $PROJECT_NAME"
        echo "  - Runtime: $PROJECT_RUNTIME"

    - name: Determine Environment
      id: determine-env
      shell: bash
      run: |
        set -e
        
        if [[ "${{ inputs.environment }}" != "auto" ]]; then
          ENV="${{ inputs.environment }}"
        else
          # Auto-detect based on branch
          BRANCH="${{ github.ref_name }}"
          if [[ "$BRANCH" == "main" || "$BRANCH" == "master" ]]; then
            ENV="dev"
          elif [[ "$BRANCH" =~ ^feature/MMDSQ ]]; then
            ENV="dev"
          elif [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            ENV="pre"  # Default for manual triggers
          else
            echo "::error::Cannot determine environment for branch: $BRANCH"
            exit 1
          fi
        fi
        
        echo "environment=$ENV" >> $GITHUB_OUTPUT
        echo "Deploying to environment: $ENV"

    - name: Get Version
      id: get-version
      shell: bash
      run: |
        set -e
        
        # Check if version is provided as input
        if [[ -n "${{ inputs.version }}" ]]; then
          VERSION="${{ inputs.version }}"
          echo "Using input version: $VERSION"
        else
          echo "ðŸ” Detecting version from project files..."
          VERSION=""
          
          # Try different version detection methods in order of preference
          
          # 1. pyproject.toml (Modern Python standard)
          if [[ -f "pyproject.toml" ]] && command -v python3 >/dev/null 2>&1; then
            echo "Found pyproject.toml, extracting version..."
            # Try to extract version using Python
            VERSION=$(python3 -c "
import sys
try:
    if sys.version_info >= (3, 11):
        import tomllib
        with open('pyproject.toml', 'rb') as f:
            data = tomllib.load(f)
    else:
        # Fallback for older Python versions
        import re
        with open('pyproject.toml', 'r') as f:
            content = f.read()
        match = re.search(r'version\s*=\s*[\"\'](.*?)[\"\']', content)
        if match:
            data = {'project': {'version': match.group(1)}}
        else:
            raise Exception('Version not found')
    print(data['project']['version'])
except Exception as e:
    print('ERROR: ' + str(e))
" 2>/dev/null | grep -v "ERROR" || echo "")
            if [[ -n "$VERSION" ]]; then
              echo "Found version in pyproject.toml: $VERSION"
            fi
          fi
          
          # 2. __version__.py (Traditional Python)
          if [[ -z "$VERSION" ]] && [[ -f "__version__.py" ]]; then
            echo "Found __version__.py, extracting version..."
            VERSION=$(python3 -c "exec(open('__version__.py').read()); print(__version__)" 2>/dev/null || echo "")
            if [[ -n "$VERSION" ]]; then
              echo "Found version in __version__.py: $VERSION"
            fi
          fi
          
          # 3. setup.py (Traditional Python)
          if [[ -z "$VERSION" ]] && [[ -f "setup.py" ]]; then
            echo "Found setup.py, extracting version..."
            VERSION=$(python3 setup.py --version 2>/dev/null || echo "")
            if [[ -n "$VERSION" ]]; then
              echo "Found version in setup.py: $VERSION"
            fi
          fi
          
          # 4. version.txt (Simple approach)
          if [[ -z "$VERSION" ]] && [[ -f "version.txt" ]]; then
            echo "Found version.txt, reading version..."
            VERSION=$(cat version.txt | tr -d '\n\r' | xargs)
            if [[ -n "$VERSION" ]]; then
              echo "Found version in version.txt: $VERSION"
            fi
          fi
          
          # 5. VERSION file (Alternative simple approach)
          if [[ -z "$VERSION" ]] && [[ -f "VERSION" ]]; then
            echo "Found VERSION file, reading version..."
            VERSION=$(cat VERSION | tr -d '\n\r' | xargs)
            if [[ -n "$VERSION" ]]; then
              echo "Found version in VERSION file: $VERSION"
            fi
          fi
          
          # 6. package.json (for Node.js compatibility)
          if [[ -z "$VERSION" ]] && [[ -f "package.json" ]]; then
            echo "Found package.json, extracting version..."
            VERSION=$(node -p "require('./package.json').version" 2>/dev/null || echo "")
            if [[ -n "$VERSION" ]]; then
              echo "Found version in package.json: $VERSION"
            fi
          fi
          
          # 7. Lambda function code (inline version)
          if [[ -z "$VERSION" ]] && [[ -f "lambda_function.py" ]]; then
            echo "Checking lambda_function.py for inline version..."
            VERSION=$(grep -E "^__version__\s*=\s*['\"]([^'\"]+)['\"]" lambda_function.py | sed -E "s/^__version__\s*=\s*['\"]([^'\"]+)['\"].*/\1/" || echo "")
            if [[ -n "$VERSION" ]]; then
              echo "Found version in lambda_function.py: $VERSION"
            fi
          fi
          
          # 8. Git tag fallback (if no other version found)
          if [[ -z "$VERSION" ]]; then
            echo "No version file found, trying git tags..."
            VERSION=$(git describe --tags --abbrev=0 2>/dev/null | sed 's/^v//' || echo "")
            if [[ -n "$VERSION" ]]; then
              echo "Found version from git tag: $VERSION"
            fi
          fi
          
          # 9. Commit hash fallback (last resort)
          if [[ -z "$VERSION" ]]; then
            echo "No version found, using commit hash..."
            VERSION=$(git rev-parse --short HEAD 2>/dev/null || echo "unknown")
            echo "::warning::No version found in any standard location, using commit SHA: $VERSION"
            echo "::warning::Consider adding a version file (pyproject.toml, version.txt, or VERSION)"
          fi
        fi
        
        # Validate version format
        if [[ ! "$VERSION" =~ ^[0-9]+\.[0-9]+\.[0-9]+.*$ ]] && [[ "$VERSION" != "unknown" ]] && [[ ! "$VERSION" =~ ^[a-f0-9]{7,}$ ]]; then
          echo "::warning::Version '$VERSION' doesn't follow semantic versioning (x.y.z)"
          echo "::warning::Consider using semantic versioning for better version management"
        fi
        
        echo "version=$VERSION" >> $GITHUB_OUTPUT
        echo "Version to deploy: $VERSION"

    - name: Setup Runtime Environment
      if: steps.deployment-mode.outputs.deployment-mode == 'deploy'
      shell: bash
      run: |
        set -e
        CONFIG_FILE="${{ steps.load-config.outputs.config-file-path }}"
        
        # Get runtime from configuration
        RUNTIME="${{ steps.load-config.outputs.project-runtime }}"
        echo "RUNTIME=$RUNTIME" >> $GITHUB_ENV
        
        # Get runtime versions from configuration (with defaults)
        case "$RUNTIME" in
          "bun")
            BUN_VERSION=$(yq eval '.project.versions.bun // "latest"' "$CONFIG_FILE")
            echo "BUN_VERSION=$BUN_VERSION" >> $GITHUB_ENV
            echo "Configuring Bun runtime (version: $BUN_VERSION)"
            ;;
          "node")
            NODE_VERSION=$(yq eval '.project.versions.node // "18"' "$CONFIG_FILE")
            echo "NODE_VERSION=$NODE_VERSION" >> $GITHUB_ENV
            echo "Configuring Node.js runtime (version: $NODE_VERSION)"
            ;;
          "python")
            PYTHON_VERSION=$(yq eval '.project.versions.python // "3.9"' "$CONFIG_FILE")
            echo "PYTHON_VERSION=$PYTHON_VERSION" >> $GITHUB_ENV
            echo "Configuring Python runtime (version: $PYTHON_VERSION)"
            ;;
        esac

    - name: Setup Bun
      if: env.RUNTIME == 'bun'
      uses: oven-sh/setup-bun@v1
      with:
        bun-version: ${{ env.BUN_VERSION }}

    - name: Setup Node.js
      if: env.RUNTIME == 'node'
      uses: actions/setup-node@v4
      with:
        node-version: ${{ env.NODE_VERSION }}
        cache: 'npm'

    - name: Setup Python
      if: env.RUNTIME == 'python'
      uses: actions/setup-python@v5
      with:
        python-version: ${{ env.PYTHON_VERSION }}

    - name: Install Dependencies
      shell: bash
      run: |
        set -e
        CONFIG_FILE="${{ steps.load-config.outputs.config-file-path }}"
        
        # Get custom install command from config, fallback to defaults
        INSTALL_CMD=$(yq eval '.build.commands.install // "auto"' "$CONFIG_FILE")
        
        if [[ "$INSTALL_CMD" != "auto" ]]; then
          echo "Using custom install command: $INSTALL_CMD"
          eval "$INSTALL_CMD"
        else
          echo "Using automatic dependency installation for $RUNTIME"
          case "$RUNTIME" in
            "bun")
              if [[ -f "bun.lockb" ]]; then
                bun install --frozen-lockfile
              else
                bun install
              fi
              ;;
            "node")
              if [[ -f "package-lock.json" ]]; then
                npm ci
              elif [[ -f "yarn.lock" ]]; then
                yarn install --frozen-lockfile
              else
                npm install
              fi
              ;;
            "python")
              if [[ -f "requirements.txt" ]]; then
                pip install -r requirements.txt
              fi
              ;;
          esac
        fi

    - name: Run Linting
      shell: bash
      run: |
        set -e
        CONFIG_FILE="${{ steps.load-config.outputs.config-file-path }}"
        
        # Get custom lint command from config
        LINT_CMD=$(yq eval '.build.commands.lint // "auto"' "$CONFIG_FILE")
        LINT_REQUIRED=$(yq eval '.build.lint_required // false' "$CONFIG_FILE")
        
        if [[ "$LINT_CMD" != "auto" && "$LINT_CMD" != "null" ]]; then
          echo "Running custom lint command: $LINT_CMD"
          if ! eval "$LINT_CMD"; then
            if [[ "$LINT_REQUIRED" == "true" ]]; then
              echo "::error::Linting failed and is required by configuration"
              exit 1
            else
              echo "::warning::Linting failed but is not required"
            fi
          fi
        else
          echo "Running automatic linting for $RUNTIME"
          LINT_SUCCESS=false
          
          case "$RUNTIME" in
            "bun")
              if bun run --silent lint 2>/dev/null; then
                echo "Running bun lint..."
                bun run lint && LINT_SUCCESS=true
              fi
              ;;
            "node")
              if npm run --silent lint 2>/dev/null; then
                echo "Running npm lint..."
                npm run lint && LINT_SUCCESS=true
              fi
              ;;
            "python")
              if command -v flake8 &> /dev/null; then
                echo "Running flake8..."
                flake8 . && LINT_SUCCESS=true || echo "Linting completed with warnings"
              fi
              ;;
          esac
          
          if [[ "$LINT_SUCCESS" == "false" && "$LINT_REQUIRED" == "true" ]]; then
            echo "::error::No lint command found but linting is required by configuration"
            exit 1
          elif [[ "$LINT_SUCCESS" == "false" ]]; then
            echo "No lint script found, skipping..."
          fi
        fi

    - name: Run Tests
      shell: bash
      run: |
        set -e
        CONFIG_FILE="${{ steps.load-config.outputs.config-file-path }}"
        
        # Get custom test command from config
        TEST_CMD=$(yq eval '.build.commands.test // "auto"' "$CONFIG_FILE")
        TESTS_REQUIRED=$(yq eval '.build.tests_required // true' "$CONFIG_FILE")
        
        if [[ "$TEST_CMD" != "auto" && "$TEST_CMD" != "null" ]]; then
          echo "Running custom test command: $TEST_CMD"
          if ! eval "$TEST_CMD"; then
            if [[ "$TESTS_REQUIRED" == "true" ]]; then
              echo "::error::Tests failed and are required by configuration"
              exit 1
            else
              echo "::warning::Tests failed but are not required"
            fi
          fi
        else
          echo "Running automatic tests for $RUNTIME"
          TESTS_SUCCESS=false
          
          case "$RUNTIME" in
            "bun")
              if bun run --silent test 2>/dev/null; then
                echo "Running bun tests..."
                bun test && TESTS_SUCCESS=true
              fi
              ;;
            "node")
              if npm run --silent test 2>/dev/null; then
                echo "Running npm tests..."
                npm test && TESTS_SUCCESS=true
              fi
              ;;
            "python")
              if command -v pytest &> /dev/null; then
                echo "Running pytest..."
                pytest && TESTS_SUCCESS=true
              elif [[ -f "test_*.py" ]] || [[ -d "tests" ]]; then
                echo "Running python tests..."
                python -m unittest discover && TESTS_SUCCESS=true
              fi
              ;;
          esac
          
          if [[ "$TESTS_SUCCESS" == "false" && "$TESTS_REQUIRED" == "true" ]]; then
            echo "::error::No test command found but tests are required by configuration"
            exit 1
          elif [[ "$TESTS_SUCCESS" == "false" ]]; then
            echo "No test script found, skipping..."
          fi
        fi

    - name: Build Lambda Package
      if: steps.deployment-mode.outputs.deployment-mode == 'deploy'
      shell: bash
      run: |
        set -e
        CONFIG_FILE="${{ steps.load-config.outputs.config-file-path }}"
        
        # Get custom build command from config
        BUILD_CMD=$(yq eval '.build.commands.build // "auto"' "$CONFIG_FILE")
        ARTIFACT_PATH=$(yq eval '.build.artifact.path // "build/lambda.zip"' "$CONFIG_FILE")
        
        # Security: Validate artifact path to prevent directory traversal
        if [[ "$ARTIFACT_PATH" =~ \.\. ]]; then
          echo "::error::Invalid artifact path contains '..': $ARTIFACT_PATH"
          exit 1
        fi
        
        # Ensure build directory exists
        BUILD_DIR=$(dirname "$ARTIFACT_PATH")
        mkdir -p "$BUILD_DIR"
        
        if [[ "$BUILD_CMD" != "auto" && "$BUILD_CMD" != "null" ]]; then
          echo "Running custom build command: $BUILD_CMD"
          if ! eval "$BUILD_CMD"; then
            echo "::error::Custom build command failed"
            exit 1
          fi
        else
          echo "Running automatic build for $RUNTIME"
          case "$RUNTIME" in
            "bun")
              if bun run --silent zip 2>/dev/null; then
                bun run zip
              elif bun run --silent build 2>/dev/null; then
                bun run build
                # Create zip if build doesn't create it
                if [[ ! -f "$ARTIFACT_PATH" ]] && [[ -d "$BUILD_DIR" ]]; then
                  cd "$BUILD_DIR" && zip -r lambda.zip . && cd - >/dev/null
                fi
              else
                echo "::error::No build script found. Please add 'zip' or 'build' script to package.json"
                exit 1
              fi
              ;;
            "node")
              if npm run --silent zip 2>/dev/null; then
                npm run zip
              elif npm run --silent build 2>/dev/null; then
                npm run build
                # Create zip if build doesn't create it
                if [[ ! -f "$ARTIFACT_PATH" ]] && [[ -d "$BUILD_DIR" ]]; then
                  cd "$BUILD_DIR" && zip -r lambda.zip . && cd - >/dev/null
                fi
              else
                echo "::error::No build script found. Please add 'zip' or 'build' script to package.json"
                exit 1
              fi
              ;;
            "python")
              # Standard Python Lambda packaging with security considerations
              TEMP_BUILD_DIR=$(mktemp -d)
              
              # Install dependencies if requirements.txt exists
              if [[ -f "requirements.txt" ]]; then
                pip install -r requirements.txt -t "$TEMP_BUILD_DIR/"
              fi
              
              # Get exclude patterns from config (handle empty case properly)
              EXCLUDE_PATTERNS=""
              if yq eval '.build.artifact.exclude_patterns' "$CONFIG_FILE" | grep -q "^-"; then
                EXCLUDE_PATTERNS=$(yq eval '.build.artifact.exclude_patterns[]' "$CONFIG_FILE" 2>/dev/null | tr '\n' ' ' || echo "")
              fi
              
              # Copy Python files, excluding test files and sensitive files
              find . -name "*.py" -not -path "./tests/*" -not -path "./.git/*" -not -name "*test*.py" -exec cp {} "$TEMP_BUILD_DIR/" \;
              
              # Copy src directory if it exists
              if [[ -d "src" ]]; then
                cp -r src/* "$TEMP_BUILD_DIR/" 2>/dev/null || true
              fi
              
              # Remove excluded files from build directory
              if [[ -n "$EXCLUDE_PATTERNS" ]]; then
                echo "Applying exclude patterns: $EXCLUDE_PATTERNS"
                cd "$TEMP_BUILD_DIR"
                for pattern in $EXCLUDE_PATTERNS; do
                  find . -name "$pattern" -delete 2>/dev/null || true
                done
                cd - >/dev/null
              fi
              
              # Create zip with the correct name and location
              cd "$TEMP_BUILD_DIR" && zip -r "$(basename "$ARTIFACT_PATH")" . && cd - >/dev/null
              mv "$TEMP_BUILD_DIR/$(basename "$ARTIFACT_PATH")" "$ARTIFACT_PATH"
              rm -rf "$TEMP_BUILD_DIR"
              ;;
          esac
        fi
        
        # Verify package was created
        if [[ ! -f "$ARTIFACT_PATH" ]]; then
          echo "::error::Lambda package not found at $ARTIFACT_PATH"
          exit 1
        fi
        
        # Security: Check package size (Lambda has limits)
        PACKAGE_SIZE=$(stat -f%z "$ARTIFACT_PATH" 2>/dev/null || stat -c%s "$ARTIFACT_PATH")
        PACKAGE_SIZE_MB=$((PACKAGE_SIZE / 1024 / 1024))
        
        if [[ $PACKAGE_SIZE_MB -gt 250 ]]; then
          echo "::warning::Lambda package is ${PACKAGE_SIZE_MB}MB, which exceeds AWS Lambda deployment package size limit (250MB unzipped)"
        fi
        
        echo "âœ… Lambda package created: $(ls -lh "$ARTIFACT_PATH")"
        echo "ARTIFACT_PATH=$ARTIFACT_PATH" >> $GITHUB_ENV

    - name: Determine AWS Authentication Type
      if: steps.determine-env.outputs.environment != 'skip'
      shell: bash
      run: |
        set -e
        CONFIG_FILE="${{ steps.load-config.outputs.config-file-path }}"
        ENV="${{ steps.determine-env.outputs.environment }}"
        
        # Get auth type from environment configuration
        AUTH_TYPE=$(yq eval ".environments.$ENV.aws.auth_type // \"access_key\"" "$CONFIG_FILE")
        
        echo "AWS_AUTH_TYPE=$AUTH_TYPE" >> $GITHUB_ENV
        echo "ðŸ” AWS Authentication Type: $AUTH_TYPE"
        
        # Set AWS region - prioritize environment variable over config
        if [[ -z "$AWS_REGION" ]]; then
          CONFIG_REGION=$(yq eval ".environments.$ENV.aws.region // \"eu-west-1\"" "$CONFIG_FILE")
          echo "AWS_REGION=$CONFIG_REGION" >> $GITHUB_ENV
          echo "ðŸŒ AWS Region (from config): $CONFIG_REGION"
        else
          echo "ðŸŒ AWS Region (from environment): $AWS_REGION"
        fi

    - name: Validate Security Requirements
      if: steps.determine-env.outputs.environment != 'skip'
      shell: bash
      run: |
        set -e
        
        echo "ðŸ”’ Validating security requirements..."
        echo "ðŸ” AWS_AUTH_TYPE: $AWS_AUTH_TYPE"
        echo "ðŸ” Environment: ${{ steps.determine-env.outputs.environment }}"
        
        # Validate required credentials are present
        if [[ "$AWS_AUTH_TYPE" == "oidc" ]]; then
          if [[ -z "$AWS_ROLE_ARN" ]]; then
            echo "::error::AWS_ROLE_ARN environment variable is required for OIDC authentication"
            exit 1
          fi
          echo "âœ… OIDC credentials validated (AWS_ROLE_ARN present)"
        elif [[ "$AWS_AUTH_TYPE" == "access_key" ]]; then
          if [[ -z "$AWS_ACCESS_KEY_ID" ]] || [[ -z "$AWS_SECRET_ACCESS_KEY" ]]; then
            echo "::error::AWS_ACCESS_KEY_ID and AWS_SECRET_ACCESS_KEY environment variables are required for access key authentication"
            exit 1
          fi
          echo "âœ… Access key credentials validated"
        else
          echo "::warning::Unknown auth type: $AWS_AUTH_TYPE, defaulting to access_key"
          echo "AWS_AUTH_TYPE=access_key" >> $GITHUB_ENV
        fi
        
        echo "âœ… All security requirements validated"

    - name: Configure AWS Credentials (OIDC)
      if: steps.determine-env.outputs.environment != 'skip' && env.AWS_AUTH_TYPE == 'oidc'
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-region: ${{ env.AWS_REGION }}
        role-to-assume: ${{ env.AWS_ROLE_ARN }}

    - name: Configure AWS Credentials (Access Keys)
      if: steps.determine-env.outputs.environment != 'skip' && env.AWS_AUTH_TYPE == 'access_key'
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-region: ${{ env.AWS_REGION }}
        # AWS_ACCESS_KEY_ID and AWS_SECRET_ACCESS_KEY are automatically picked up from environment

    - name: Validate AWS Configuration
      if: steps.determine-env.outputs.environment != 'skip'
      shell: bash
      run: |
        set -e
        
        echo "Validating AWS configuration..."
        
        # Test AWS credentials
        if ! aws sts get-caller-identity > /dev/null 2>&1; then
          echo "::error::AWS credentials validation failed"
          exit 1
        fi
        
        # Validate S3 bucket exists and is accessible
        if ! aws s3 ls "s3://${{ env.S3_BUCKET_NAME }}" > /dev/null 2>&1; then
          echo "::error::Cannot access S3 bucket: ${{ env.S3_BUCKET_NAME }}"
          exit 1
        fi
        
        # Validate Lambda function exists
        if ! aws lambda get-function --function-name "${{ env.LAMBDA_FUNCTION_NAME }}" > /dev/null 2>&1; then
          echo "::error::Lambda function not found: ${{ env.LAMBDA_FUNCTION_NAME }}"
          exit 1
        fi
        
        echo "âœ… AWS configuration validated successfully"

    - name: Check Version Conflicts
      id: version-check
      shell: bash
      run: |
        set -e
        
        ENV="${{ steps.determine-env.outputs.environment }}"
        VERSION="${{ steps.get-version.outputs.version }}"
        S3_BUCKET="${{ env.S3_BUCKET_NAME }}"
        LAMBDA_FUNCTION="${{ env.LAMBDA_FUNCTION_NAME }}"
        FORCE_DEPLOY="${{ inputs.force-deploy }}"
        
        # Skip version check for dev environment or if force deploy is enabled
        if [[ "$ENV" == "dev" || "$FORCE_DEPLOY" == "true" ]]; then
          echo "Skipping version conflict check for $ENV environment or force deployment"
          echo "can-deploy=true" >> $GITHUB_OUTPUT
          exit 0
        fi
        
        # Check if version already exists in S3
        if aws s3 ls "s3://$S3_BUCKET/$LAMBDA_FUNCTION/versions/$VERSION/" > /dev/null 2>&1; then
          echo "::warning::Version $VERSION already exists in S3"
          echo "::error::Version conflict detected. Use force-deploy: true to override, or increment the version."
          echo "can-deploy=false" >> $GITHUB_OUTPUT
          exit 1
        fi
        
        echo "âœ… No version conflicts detected"
        echo "can-deploy=true" >> $GITHUB_OUTPUT

    - name: Retrieve Rollback Artifact
      id: retrieve-rollback
      if: steps.deployment-mode.outputs.deployment-mode == 'rollback'
      shell: bash
      run: |
        set -e
        
        echo "ðŸ”„ Retrieving rollback artifact from S3..."
        
        # Set variables
        ROLLBACK_VERSION="${{ steps.deployment-mode.outputs.target-version }}"
        S3_BUCKET="$S3_BUCKET_NAME"
        LAMBDA_FUNCTION="$LAMBDA_FUNCTION_NAME"
        
        # Normalize version (remove 'v' prefix if present)
        NORMALIZED_VERSION=$(echo "$ROLLBACK_VERSION" | sed 's/^v//')
        
        # Construct S3 key for the rollback version
        S3_KEY="${LAMBDA_FUNCTION}/${NORMALIZED_VERSION}/${LAMBDA_FUNCTION}-${NORMALIZED_VERSION}.zip"
        
        echo "ðŸ” Looking for rollback artifact:"
        echo "S3 Bucket: $S3_BUCKET"
        echo "S3 Key: $S3_KEY"
        
        # Check if the rollback version exists in S3
        if ! aws s3api head-object --bucket "$S3_BUCKET" --key "$S3_KEY" > /dev/null 2>&1; then
          echo "::error::Rollback version $ROLLBACK_VERSION not found in S3"
          echo "::error::S3 location: s3://$S3_BUCKET/$S3_KEY"
          echo "::error::Available versions:"
          aws s3 ls "s3://$S3_BUCKET/$LAMBDA_FUNCTION/" --recursive | grep "\.zip$" | head -10 || echo "No versions found"
          exit 1
        fi
        
        echo "âœ… Rollback artifact found in S3"
        
        # Create deployment directory
        mkdir -p deployment
        
        # Download the rollback artifact
        echo "ðŸ“¥ Downloading rollback artifact..."
        aws s3 cp "s3://$S3_BUCKET/$S3_KEY" "deployment/${LAMBDA_FUNCTION}-${NORMALIZED_VERSION}.zip"
        
        if [[ ! -f "deployment/${LAMBDA_FUNCTION}-${NORMALIZED_VERSION}.zip" ]]; then
          echo "::error::Failed to download rollback artifact"
          exit 1
        fi
        
        # Verify the downloaded file
        FILE_SIZE=$(stat -f%z "deployment/${LAMBDA_FUNCTION}-${NORMALIZED_VERSION}.zip" 2>/dev/null || stat -c%s "deployment/${LAMBDA_FUNCTION}-${NORMALIZED_VERSION}.zip" 2>/dev/null)
        echo "ðŸ“¦ Downloaded artifact size: $FILE_SIZE bytes"
        
        if [[ $FILE_SIZE -lt 1000 ]]; then
          echo "::warning::Downloaded file seems too small ($FILE_SIZE bytes)"
        fi
        
        # Set outputs for deployment step
        echo "s3-key=$S3_KEY" >> $GITHUB_OUTPUT
        echo "local-file=deployment/${LAMBDA_FUNCTION}-${NORMALIZED_VERSION}.zip" >> $GITHUB_OUTPUT
        echo "version=$NORMALIZED_VERSION" >> $GITHUB_OUTPUT
        
        echo "âœ… Rollback artifact ready for deployment"

    - name: Deploy to S3 and Lambda
      id: deploy-to-s3
      if: steps.version-check.outputs.can-deploy == 'true' || steps.deployment-mode.outputs.deployment-mode == 'rollback'
      shell: bash
      run: |
        set -e
        
        ENV="${{ steps.determine-env.outputs.environment }}"
        S3_BUCKET="${{ env.S3_BUCKET_NAME }}"
        LAMBDA_FUNCTION="${{ env.LAMBDA_FUNCTION_NAME }}"
        DEPLOYMENT_MODE="${{ steps.deployment-mode.outputs.deployment-mode }}"
        
        if [[ "$DEPLOYMENT_MODE" == "rollback" ]]; then
          # Rollback deployment
          VERSION="${{ steps.retrieve-rollback.outputs.version }}"
          S3_KEY="${{ steps.retrieve-rollback.outputs.s3-key }}"
          ARTIFACT_PATH="${{ steps.retrieve-rollback.outputs.local-file }}"
          
          echo "ðŸ”„ Starting rollback deployment to $ENV environment..."
          echo "  Rollback to Version: $VERSION"
          echo "  S3 Bucket: $S3_BUCKET"
          echo "  Lambda Function: $LAMBDA_FUNCTION"
          echo "  Rollback Package: $ARTIFACT_PATH"
          echo "  S3 Key: $S3_KEY"
          
        else
          # Normal deployment
          VERSION="${{ steps.get-version.outputs.version }}"
          ARTIFACT_PATH="${{ env.ARTIFACT_PATH }}"
          
          echo "ðŸš€ Starting deployment to $ENV environment..."
          echo "  Version: $VERSION"
          echo "  S3 Bucket: $S3_BUCKET"
          echo "  Lambda Function: $LAMBDA_FUNCTION"
          echo "  Package: $ARTIFACT_PATH"
          
          # Generate unique S3 key for this deployment
          TIMESTAMP=$(date +%s)
          S3_KEY_BASE="$LAMBDA_FUNCTION"
          
          # Upload to S3 with retry logic
          echo "ðŸ“¦ Uploading package to S3..."
          if [[ "$ENV" == "dev" ]]; then
            # For dev, use timestamp to avoid conflicts
            S3_KEY="$S3_KEY_BASE/dev/$TIMESTAMP/lambda.zip"
            aws s3 cp "$ARTIFACT_PATH" "s3://$S3_BUCKET/$S3_KEY" --metadata "environment=$ENV,version=$VERSION,timestamp=$TIMESTAMP"
          else
            # For pre/prod, use versioning
            S3_KEY="$S3_KEY_BASE/$VERSION/$LAMBDA_FUNCTION-$VERSION.zip"
            aws s3 cp "$ARTIFACT_PATH" "s3://$S3_BUCKET/$S3_KEY" --metadata "environment=$ENV,version=$VERSION"
          fi
          
          echo "âœ… Package uploaded to s3://$S3_BUCKET/$S3_KEY"
        fi
          aws s3 cp "$ARTIFACT_PATH" "s3://$S3_BUCKET/$S3_KEY_BASE/latest/lambda.zip" --metadata "environment=$ENV,version=$VERSION"
        fi
        
        # Update Lambda function with retry logic
        echo "ðŸ”„ Updating Lambda function..."
        RETRY_COUNT=0
        MAX_RETRIES=3
        
        while [[ $RETRY_COUNT -lt $MAX_RETRIES ]]; do
          if aws lambda update-function-code \
            --function-name "$LAMBDA_FUNCTION" \
            --s3-bucket "$S3_BUCKET" \
            --s3-key "$S3_KEY" \
            --publish > /tmp/lambda-update.json; then
            break
          else
            ((RETRY_COUNT++))
            if [[ $RETRY_COUNT -eq $MAX_RETRIES ]]; then
              echo "::error::Failed to update Lambda function after $MAX_RETRIES attempts"
              exit 1
            fi
            echo "Retry $RETRY_COUNT/$MAX_RETRIES in 10 seconds..."
            sleep 10
          fi
        done
        
        # Get the deployed version info
        LAMBDA_VERSION=$(jq -r '.Version' /tmp/lambda-update.json)
        LAMBDA_SIZE=$(jq -r '.CodeSize' /tmp/lambda-update.json)
        
        # Tag the version with comprehensive metadata
        ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
        COMMIT_SHA_SHORT=$(git rev-parse --short HEAD 2>/dev/null || echo "unknown")
        BRANCH_NAME="${{ github.ref_name }}"
        TIMESTAMP=$(date +%s)
        
        if [[ "$DEPLOYMENT_MODE" == "rollback" ]]; then
          # Rollback-specific tagging
          TAGS="Version=$VERSION,Environment=$ENV,DeploymentType=rollback,RollbackBy=${{ github.actor }},RollbackTimestamp=$TIMESTAMP,Branch=$BRANCH_NAME"
          echo "ðŸ·ï¸ Tagging Lambda function for rollback deployment..."
        else
          # Normal deployment tagging
          TAGS="Version=$VERSION,Environment=$ENV,DeploymentType=deploy,CommitSHA=$COMMIT_SHA_SHORT,Branch=$BRANCH_NAME,DeployedBy=${{ github.actor }},Timestamp=$TIMESTAMP"
          echo "ðŸ·ï¸ Tagging Lambda function for normal deployment..."
        fi
        
        aws lambda tag-resource \
          --resource "arn:aws:lambda:${{ env.AWS_REGION }}:$ACCOUNT_ID:function:$LAMBDA_FUNCTION" \
          --tags "$TAGS" || echo "::warning::Failed to tag Lambda function"
        
        if [[ "$DEPLOYMENT_MODE" == "rollback" ]]; then
          echo "âœ… Rollback completed successfully!"
          echo "  Rolled back to Version: $VERSION"
        else
          echo "âœ… Deployment completed successfully!"
          echo "  Deployed Version: $VERSION"
        fi
        
        echo "  Lambda Version: $LAMBDA_VERSION"
        echo "  Package Size: $(numfmt --to=iec $LAMBDA_SIZE)"
        echo "  S3 Location: s3://$S3_BUCKET/$S3_KEY"
        
        # Set outputs for next steps
        echo "lambda-version=$LAMBDA_VERSION" >> $GITHUB_OUTPUT
        echo "s3-location=s3://$S3_BUCKET/$S3_KEY" >> $GITHUB_OUTPUT
        echo "package-size=$LAMBDA_SIZE" >> $GITHUB_OUTPUT
        echo "deployment-type=$DEPLOYMENT_MODE" >> $GITHUB_OUTPUT

    - name: Validate Deployment
      id: validate-deployment
      if: steps.version-check.outputs.can-deploy == 'true'
      shell: bash
      run: |
        set -e
        
        LAMBDA_FUNCTION="${{ env.LAMBDA_FUNCTION_NAME }}"
        
        echo "ðŸ” Validating deployment..."
        
        # Wait for function to be ready with timeout and better error handling
        echo "Waiting for Lambda function to be active..."
        
        # Use a custom wait loop instead of aws lambda wait function-active
        MAX_ATTEMPTS=30
        ATTEMPT=0
        
        while [ $ATTEMPT -lt $MAX_ATTEMPTS ]; do
          FUNCTION_INFO=$(aws lambda get-function --function-name "$LAMBDA_FUNCTION" 2>/dev/null || echo '{}')
          STATE=$(echo "$FUNCTION_INFO" | jq -r '.Configuration.State // "Unknown"')
          LAST_UPDATE_STATUS=$(echo "$FUNCTION_INFO" | jq -r '.Configuration.LastUpdateStatus // "Unknown"')
          
          echo "Attempt $((ATTEMPT + 1))/$MAX_ATTEMPTS - State: $STATE, LastUpdateStatus: $LAST_UPDATE_STATUS"
          
          if [[ "$STATE" == "Active" && "$LAST_UPDATE_STATUS" == "Successful" ]]; then
            echo "âœ… Lambda function is active and ready"
            break
          elif [[ "$LAST_UPDATE_STATUS" == "Failed" ]]; then
            echo "::error::Lambda function update failed: $LAST_UPDATE_STATUS"
            exit 1
          fi
          
          ATTEMPT=$((ATTEMPT + 1))
          sleep 10
        done
        
        if [ $ATTEMPT -eq $MAX_ATTEMPTS ]; then
          echo "::warning::Timeout waiting for Lambda function to be active"
          echo "::warning::Current state: $STATE, LastUpdateStatus: $LAST_UPDATE_STATUS"
          echo "::warning::Deployment may still be in progress, but continuing..."
        fi
        
        # Get final function configuration
        FUNCTION_INFO=$(aws lambda get-function --function-name "$LAMBDA_FUNCTION")
        STATE=$(echo "$FUNCTION_INFO" | jq -r '.Configuration.State')
        LAST_UPDATE_STATUS=$(echo "$FUNCTION_INFO" | jq -r '.Configuration.LastUpdateStatus')
        
        if [[ "$STATE" != "Active" ]]; then
          echo "::warning::Lambda function is not in Active state: $STATE"
          echo "::warning::This may be normal if the deployment is still in progress"
        else
          echo "âœ… Lambda function is in Active state"
        fi
        
        if [[ "$LAST_UPDATE_STATUS" != "Successful" ]]; then
          if [[ "$LAST_UPDATE_STATUS" == "InProgress" ]]; then
            echo "::warning::Lambda function update is still in progress: $LAST_UPDATE_STATUS"
            echo "::warning::Deployment may complete after this workflow finishes"
          else
            echo "::error::Lambda function update failed: $LAST_UPDATE_STATUS"
            exit 1
          fi
        else
          echo "âœ… Lambda function update was successful"
        fi
        
        # Optional: Test function with a simple invocation (if test payload is configured)
        CONFIG_FILE="${{ steps.load-config.outputs.config-file-path }}"
        HEALTH_CHECK_ENABLED=$(yq eval '.deployment.health_check.enabled // true' "$CONFIG_FILE")
        
        if [[ "$HEALTH_CHECK_ENABLED" == "false" ]]; then
          echo "Health check is disabled in configuration"
        else
          DEPLOYMENT_MODE="${{ steps.deployment-mode.outputs.deployment-mode }}"
          if [[ "$DEPLOYMENT_MODE" == "rollback" ]]; then
            echo "Running health check after rollback..."
          else
            echo "Running health check with test payload..."
          fi
          
          # Get test payload from configuration
          CONFIG_FILE="${{ steps.load-config.outputs.config-file-path }}"
          TEST_PAYLOAD=$(yq eval '.deployment.health_check.test_payload // null' "$CONFIG_FILE")
          TEST_PAYLOAD_OBJECT=$(yq eval '.deployment.health_check.test_payload_object // null' "$CONFIG_FILE")
          
          # Determine which payload format to use
          if [[ "$TEST_PAYLOAD_OBJECT" != "null" ]]; then
            echo "Using YAML object format for payload"
            # Convert YAML object to JSON and clean it
            yq eval '.deployment.health_check.test_payload_object' "$CONFIG_FILE" -o json | tr -d '\r\n\t' | sed 's/[[:cntrl:]]//g' > /tmp/raw-payload.json
            # Remove any trailing whitespace and ensure clean JSON
            jq -c . /tmp/raw-payload.json > /tmp/test-payload.json 2>/dev/null || {
              echo "::error::Invalid YAML object in test_payload_object"
              return 1
            }
            rm -f /tmp/raw-payload.json
          elif [[ "$TEST_PAYLOAD" != "null" ]]; then
            echo "Using JSON string format for payload"
            # Clean the JSON string and create file
            CLEANED_PAYLOAD=$(echo "$TEST_PAYLOAD" | tr -d '\r\n\t' | sed 's/[[:cntrl:]]//g' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
            echo "$CLEANED_PAYLOAD" | jq -c . > /tmp/test-payload.json 2>/dev/null || {
              echo "::error::Invalid JSON in test_payload: $TEST_PAYLOAD"
              return 1
            }
          else
            echo "No test payload configured, using default"
            printf '{"name":"Test","source":"deployment"}' > /tmp/test-payload.json
          fi
          
          echo "Using test payload:"
          cat /tmp/test-payload.json
          echo ""
          echo "File size: $(wc -c < /tmp/test-payload.json) bytes"
          
          # Validate JSON syntax
          if ! jq . /tmp/test-payload.json > /dev/null 2>&1; then
            echo "::error::Invalid JSON in test payload"
            cat /tmp/test-payload.json
            rm -f /tmp/test-payload.json
            return 1
          fi
          
          echo "JSON validation passed, invoking Lambda..."
          
          # Base64 encode the payload for AWS CLI
          PAYLOAD_BASE64=$(cat /tmp/test-payload.json | base64 -w 0)
          echo "Payload ready for Lambda invocation"
          
          # Invoke the function using base64 payload
          if aws lambda invoke \
            --function-name "$LAMBDA_FUNCTION" \
            --payload "$PAYLOAD_BASE64" \
            /tmp/test-response.json \
            --cli-read-timeout 30 \
            --cli-connect-timeout 10 > /tmp/invoke-output.json 2>&1; then
            
            echo "âœ… Lambda invocation succeeded"
            
            # Check the response
            if [[ -f "/tmp/test-response.json" ]]; then
              echo "ðŸ“‹ Lambda response:"
              cat /tmp/test-response.json | jq . 2>/dev/null || cat /tmp/test-response.json
              
              # Get expected response validation from config
              EXPECTED_STATUS_CODE=$(yq eval '.deployment.health_check.expected_status_code // 200' "$CONFIG_FILE")
              EXPECTED_RESPONSE_CONTAINS=$(yq eval '.deployment.health_check.expected_response_contains // null' "$CONFIG_FILE")
              EXPECTED_ERROR_MESSAGE=$(yq eval '.deployment.health_check.expected_error_message // null' "$CONFIG_FILE")
              
              echo "ðŸ” Validating response..."
              VALIDATION_PASSED=true
              
              # Check if response contains an error
              if grep -q '"errorMessage"' /tmp/test-response.json 2>/dev/null; then
                ERROR_MESSAGE=$(jq -r '.errorMessage // "Unknown error"' /tmp/test-response.json 2>/dev/null)
                ERROR_TYPE=$(jq -r '.errorType // "Unknown"' /tmp/test-response.json 2>/dev/null)
                
                if [[ "$EXPECTED_ERROR_MESSAGE" != "null" ]]; then
                  echo "Expected error response, checking error message..."
                  if echo "$ERROR_MESSAGE" | grep -q "$EXPECTED_ERROR_MESSAGE"; then
                    echo "âœ… Expected error message found: $ERROR_MESSAGE"
                  else
                    echo "::warning::Error message doesn't match expected pattern"
                    echo "::warning::Expected: $EXPECTED_ERROR_MESSAGE"
                    echo "::warning::Actual: $ERROR_MESSAGE"
                    VALIDATION_PASSED=false
                  fi
                else
                  echo "::warning::Lambda function returned an error: $ERROR_TYPE - $ERROR_MESSAGE"
                  echo "::warning::Function deployed successfully but has runtime issues"
                  VALIDATION_PASSED=false
                fi
              else
                # No error in response, validate success response
                echo "No error in response, validating success response..."
                
                # Check status code if response has one
                if jq -e '.statusCode' /tmp/test-response.json > /dev/null 2>&1; then
                  ACTUAL_STATUS_CODE=$(jq -r '.statusCode' /tmp/test-response.json)
                  echo "Response status code: $ACTUAL_STATUS_CODE"
                  
                  if [[ "$ACTUAL_STATUS_CODE" != "$EXPECTED_STATUS_CODE" ]]; then
                    echo "::warning::Status code mismatch"
                    echo "::warning::Expected: $EXPECTED_STATUS_CODE"
                    echo "::warning::Actual: $ACTUAL_STATUS_CODE"
                    VALIDATION_PASSED=false
                  else
                    echo "âœ… Status code matches expected: $EXPECTED_STATUS_CODE"
                  fi
                fi
                
                # Check if response contains expected content
                if [[ "$EXPECTED_RESPONSE_CONTAINS" != "null" ]]; then
                  echo "Checking if response contains: $EXPECTED_RESPONSE_CONTAINS"
                  if grep -q "$EXPECTED_RESPONSE_CONTAINS" /tmp/test-response.json; then
                    echo "âœ… Response contains expected content"
                  else
                    echo "::warning::Response doesn't contain expected content: $EXPECTED_RESPONSE_CONTAINS"
                    VALIDATION_PASSED=false
                  fi
                fi
                
                # Check response body if it exists
                if jq -e '.body' /tmp/test-response.json > /dev/null 2>&1; then
                  RESPONSE_BODY=$(jq -r '.body' /tmp/test-response.json)
                  echo "Response body: $RESPONSE_BODY"
                  
                  # Try to parse body as JSON if it looks like JSON
                  if echo "$RESPONSE_BODY" | jq . > /dev/null 2>&1; then
                    echo "Response body is valid JSON"
                    PARSED_BODY=$(echo "$RESPONSE_BODY" | jq .)
                    echo "Parsed body: $PARSED_BODY"
                    
                    # Additional validation on parsed body if needed
                    if [[ "$EXPECTED_RESPONSE_CONTAINS" != "null" ]]; then
                      if echo "$PARSED_BODY" | grep -q "$EXPECTED_RESPONSE_CONTAINS"; then
                        echo "âœ… Parsed body contains expected content"
                      fi
                    fi
                  fi
                fi
              fi
              
              # Final validation result
              if [[ "$VALIDATION_PASSED" == "true" ]]; then
                echo "âœ… Health check passed - function is working correctly"
              else
                echo "::warning::Health check validation failed - function may have issues"
                echo "::warning::Function deployed successfully but response validation failed"
              fi
              
            else
              echo "::warning::No response file generated"
              VALIDATION_PASSED=false
            fi
            
            # Show invocation metadata
            if [[ -f "/tmp/invoke-output.json" ]]; then
              echo "ðŸ“Š Invocation metadata:"
              cat /tmp/invoke-output.json | jq . 2>/dev/null || cat /tmp/invoke-output.json
            fi
            
          else
            echo "::warning::Health check failed - Lambda invocation failed"
            echo "ðŸ“‹ Error details:"
            cat /tmp/invoke-output.json 2>/dev/null || echo "No error details available"
            echo "::warning::Function may still work for other inputs or after initialization"
          fi
          
          # Clean up temporary files
          rm -f /tmp/test-payload.json /tmp/test-response.json /tmp/invoke-output.json
        fi
        
        echo "âœ… Deployment validation completed successfully!"
        echo "deployment-validated=true" >> $GITHUB_OUTPUT

    - name: Send Teams Notification
      if: steps.determine-env.outputs.environment == 'dev' && env.TEAMS_WEBHOOK_URL != '' && steps.validate-deployment.outputs.deployment-validated == 'true'
      shell: bash
      run: |
        set -e
        
        # Prepare Teams message payload
        WEBHOOK_URL="${{ env.TEAMS_WEBHOOK_URL }}"
        VERSION="${{ steps.get-version.outputs.version }}"
        FUNCTION_NAME="${{ env.LAMBDA_FUNCTION_NAME }}"
        LAMBDA_VERSION="${{ steps.deploy-to-s3.outputs.lambda-version }}"
        PACKAGE_SIZE_BYTES="${{ steps.deploy-to-s3.outputs.package-size }}"
        
        # Convert package size to human readable format
        if command -v numfmt &> /dev/null && [[ -n "$PACKAGE_SIZE_BYTES" ]]; then
          PACKAGE_SIZE=$(numfmt --to=iec "$PACKAGE_SIZE_BYTES")
        else
          PACKAGE_SIZE="${PACKAGE_SIZE_BYTES:-Unknown} bytes"
        fi
        
        # Create Teams adaptive card payload
        PAYLOAD=$(cat <<EOF
        {
          "@type": "MessageCard",
          "@context": "https://schema.org/extensions",
          "themeColor": "28a745",
          "summary": "Lambda Deployment Successful",
          "sections": [{
            "activityTitle": "ðŸš€ Production Deployment Successful",
            "activitySubtitle": "Lambda Function: **$FUNCTION_NAME**",
            "activityImage": "https://github.githubassets.com/images/modules/logos_page/GitHub-Mark.png",
            "facts": [{
              "name": "Version Deployed:",
              "value": "$VERSION"
            }, {
              "name": "Lambda Version:",
              "value": "$LAMBDA_VERSION"
            }, {
              "name": "Package Size:",
              "value": "$PACKAGE_SIZE"
            }, {
              "name": "Deployed By:",
              "value": "${{ github.actor }}"
            }, {
              "name": "Repository:",
              "value": "${{ github.repository }}"
            }, {
              "name": "Environment:",
              "value": "PRODUCTION"
            }, {
              "name": "Commit:",
              "value": "${{ github.sha }}"
            }],
            "markdown": true
          }],
          "potentialAction": [{
            "@type": "OpenUri",
            "name": "View Workflow Execution",
            "targets": [{
              "os": "default",
              "uri": "https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}"
            }]
          }, {
            "@type": "OpenUri", 
            "name": "View Repository",
            "targets": [{
              "os": "default",
              "uri": "https://github.com/${{ github.repository }}"
            }]
          }]
        }
        EOF
        )
        
        echo "Sending Teams notification..."
        
        # Send notification with retry logic
        RETRY_COUNT=0
        MAX_RETRIES=3
        
        while [[ $RETRY_COUNT -lt $MAX_RETRIES ]]; do
          if curl -H "Content-Type: application/json" \
                  -d "$PAYLOAD" \
                  -w "HTTP Status: %{http_code}\n" \
                  -o /tmp/teams-response.json \
                  "$WEBHOOK_URL"; then
            
            HTTP_STATUS=$(curl -s -o /dev/null -w "%{http_code}" \
                              -H "Content-Type: application/json" \
                              -d "$PAYLOAD" \
                              "$WEBHOOK_URL")
            
            if [[ "$HTTP_STATUS" == "200" ]]; then
              echo "âœ… Teams notification sent successfully"
              break
            else
              echo "âš ï¸ Teams notification returned HTTP $HTTP_STATUS"
              cat /tmp/teams-response.json 2>/dev/null || echo "No response body"
            fi
          fi
          
          ((RETRY_COUNT++))
          if [[ $RETRY_COUNT -eq $MAX_RETRIES ]]; then
            echo "::warning::Failed to send Teams notification after $MAX_RETRIES attempts"
            echo "This does not affect the deployment success"
            break
          fi
          
          echo "Retrying Teams notification ($RETRY_COUNT/$MAX_RETRIES) in 5 seconds..."
          sleep 5
        done

    - name: Auto-Rollback on Failure
      id: auto-rollback
      if: failure() && steps.deployment-mode.outputs.deployment-mode == 'deploy' && steps.get-last-version.outputs.last-version != ''
      shell: bash
      run: |
        set -e
        
        echo "ðŸš¨ Deployment failure detected, checking auto-rollback configuration..."
        
        # Load auto-rollback configuration
        CONFIG_FILE="${{ steps.load-config.outputs.config-file-path }}"
        AUTO_ROLLBACK_ENABLED=$(yq eval '.deployment.auto_rollback.enabled // false' "$CONFIG_FILE")
        ON_DEPLOYMENT_FAILURE=$(yq eval '.deployment.auto_rollback.triggers.on_deployment_failure // true' "$CONFIG_FILE")
        MAX_ATTEMPTS=$(yq eval '.deployment.auto_rollback.behavior.max_attempts // 1' "$CONFIG_FILE")
        STRATEGY=$(yq eval '.deployment.auto_rollback.strategy // "last_successful"' "$CONFIG_FILE")
        
        if [[ "$AUTO_ROLLBACK_ENABLED" != "true" ]]; then
          echo "Auto-rollback is disabled, skipping automatic rollback"
          exit 0
        fi
        
        if [[ "$ON_DEPLOYMENT_FAILURE" != "true" ]]; then
          echo "Auto-rollback on deployment failure is disabled"
          exit 0
        fi
        
        echo "ðŸ”„ Auto-rollback is enabled, initiating rollback..."
        
        # Determine rollback target version
        ROLLBACK_VERSION=""
        case "$STRATEGY" in
          "last_successful")
            ROLLBACK_VERSION="${{ steps.get-last-version.outputs.last-version }}"
            echo "Using last successful version: $ROLLBACK_VERSION"
            ;;
          "specific_version")
            ROLLBACK_VERSION=$(yq eval '.deployment.auto_rollback.target_version // ""' "$CONFIG_FILE")
            echo "Using specific version: $ROLLBACK_VERSION"
            ;;
          *)
            echo "::error::Unknown rollback strategy: $STRATEGY"
            exit 1
            ;;
        esac
        
        if [[ -z "$ROLLBACK_VERSION" ]]; then
          echo "::error::No rollback target version available"
          echo "::error::Cannot perform automatic rollback"
          exit 1
        fi
        
        echo "ðŸŽ¯ Rolling back to version: $ROLLBACK_VERSION"
        
        # Set environment variables for rollback
        ENV="${{ steps.determine-env.outputs.environment }}"
        S3_BUCKET="$S3_BUCKET_NAME"
        LAMBDA_FUNCTION="$LAMBDA_FUNCTION_NAME"
        
        # Normalize version (remove 'v' prefix if present)
        NORMALIZED_VERSION=$(echo "$ROLLBACK_VERSION" | sed 's/^v//')
        
        # Construct S3 key for the rollback version
        S3_KEY="${LAMBDA_FUNCTION}/${NORMALIZED_VERSION}/${LAMBDA_FUNCTION}-${NORMALIZED_VERSION}.zip"
        
        echo "ðŸ” Checking if rollback version exists in S3..."
        if ! aws s3api head-object --bucket "$S3_BUCKET" --key "$S3_KEY" > /dev/null 2>&1; then
          echo "::error::Rollback version $ROLLBACK_VERSION not found in S3"
          echo "::error::S3 location: s3://$S3_BUCKET/$S3_KEY"
          exit 1
        fi
        
        echo "âœ… Rollback version found, proceeding with rollback..."
        
        # Update Lambda function with rollback version
        echo "ðŸ”„ Updating Lambda function to rollback version..."
        if aws lambda update-function-code \
          --function-name "$LAMBDA_FUNCTION" \
          --s3-bucket "$S3_BUCKET" \
          --s3-key "$S3_KEY" \
          --publish > /tmp/rollback-update.json; then
          
          # Get rollback deployment info
          LAMBDA_VERSION=$(jq -r '.Version' /tmp/rollback-update.json)
          LAMBDA_SIZE=$(jq -r '.CodeSize' /tmp/rollback-update.json)
          
          # Tag the rollback
          ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          TIMESTAMP=$(date +%s)
          TAGS="Version=$NORMALIZED_VERSION,Environment=$ENV,DeploymentType=auto-rollback,RollbackBy=system,RollbackTimestamp=$TIMESTAMP,RollbackReason=deployment-failure"
          
          aws lambda tag-resource \
            --resource "arn:aws:lambda:$AWS_REGION:$ACCOUNT_ID:function:$LAMBDA_FUNCTION" \
            --tags "$TAGS" || echo "::warning::Failed to tag rollback"
          
          echo "âœ… Auto-rollback completed successfully!"
          echo "  Rolled back to Version: $NORMALIZED_VERSION"
          echo "  Lambda Version: $LAMBDA_VERSION"
          echo "  Package Size: $(numfmt --to=iec $LAMBDA_SIZE)"
          echo "  S3 Location: s3://$S3_BUCKET/$S3_KEY"
          
          # Set outputs
          echo "rollback-completed=true" >> $GITHUB_OUTPUT
          echo "rollback-version=$NORMALIZED_VERSION" >> $GITHUB_OUTPUT
          
        else
          echo "::error::Auto-rollback failed"
          echo "::error::Both original deployment and rollback have failed"
          exit 1
        fi

    - name: Auto-Rollback Health Check
      if: steps.auto-rollback.outputs.rollback-completed == 'true'
      shell: bash
      run: |
        echo "ðŸ” Running health check after auto-rollback..."
        
        # Load health check configuration
        CONFIG_FILE="${{ steps.load-config.outputs.config-file-path }}"
        VALIDATE_ROLLBACK=$(yq eval '.deployment.auto_rollback.behavior.validate_rollback // true' "$CONFIG_FILE")
        
        if [[ "$VALIDATE_ROLLBACK" != "true" ]]; then
          echo "Rollback validation is disabled, skipping health check"
          exit 0
        fi
        
        # Run the same health check logic as normal deployment
        HEALTH_CHECK_ENABLED=$(yq eval '.deployment.health_check.enabled // true' "$CONFIG_FILE")
        
        if [[ "$HEALTH_CHECK_ENABLED" == "false" ]]; then
          echo "Health check is disabled in configuration"
          echo "âœ… Auto-rollback completed (health check skipped)"
        else
          echo "Running health check after auto-rollback..."
          
          # Simple health check - just invoke the function
          LAMBDA_FUNCTION="$LAMBDA_FUNCTION_NAME"
          
          if aws lambda invoke \
            --function-name "$LAMBDA_FUNCTION" \
            --payload '{"source":"auto-rollback-validation"}' \
            /tmp/rollback-health-response.json > /dev/null 2>&1; then
            echo "âœ… Auto-rollback health check passed"
            echo "âœ… System successfully rolled back and is functional"
          else
            echo "::warning::Auto-rollback health check failed"
            echo "::warning::Rollback completed but function may have issues"
          fi
        fi

