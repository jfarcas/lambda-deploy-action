# Fixed S3 Structure with Environment Isolation
# This fixes the critical S3 path and version checking issues

- name: Fixed Version Conflict Check
  id: version-check
  shell: bash
  run: |
    set -e
    
    ENV="${{ steps.determine-env.outputs.environment }}"
    VERSION="${{ steps.get-version.outputs.version }}"
    S3_BUCKET="${{ env.S3_BUCKET_NAME }}"
    LAMBDA_FUNCTION="${{ env.LAMBDA_FUNCTION_NAME }}"
    FORCE_DEPLOY="${{ inputs.force-deploy }}"
    
    echo "🔍 Fixed Version Conflict Check with Environment Isolation"
    echo "Environment: $ENV"
    echo "Version: $VERSION"
    echo "Force Deploy: $FORCE_DEPLOY"
    echo ""
    
    # Environment-specific version checking with correct S3 paths
    case "$ENV" in
      "dev"|"development")
        echo "🔧 Development Environment: Always allow deployment"
        echo "can-deploy=true" >> $GITHUB_OUTPUT
        ;;
        
      "pre"|"staging"|"test")
        echo "🧪 Staging Environment: Check for version conflicts in staging"
        
        # Check if version exists in PRE environment specifically
        PRE_S3_PATH="s3://$S3_BUCKET/$LAMBDA_FUNCTION/environments/pre/versions/$VERSION/"
        
        if [[ "$FORCE_DEPLOY" == "true" ]]; then
          echo "🚨 Force deployment enabled - bypassing version checks"
          echo "can-deploy=true" >> $GITHUB_OUTPUT
        elif aws s3 ls "$PRE_S3_PATH" > /dev/null 2>&1; then
          echo "⚠️  Version $VERSION already exists in PRE environment"
          echo "::warning::Version $VERSION exists in staging environment"
          echo "::notice::Allowing overwrite for staging testing flexibility"
          echo "::notice::Consider using pre-release versions: $VERSION-rc.1"
          echo "can-deploy=true" >> $GITHUB_OUTPUT
        else
          echo "✅ Version $VERSION is new in PRE environment"
          echo "can-deploy=true" >> $GITHUB_OUTPUT
        fi
        ;;
        
      "prod"|"production")
        echo "🏭 Production Environment: Strict version conflict checking"
        
        # Check if version exists in PROD environment specifically
        PROD_S3_PATH="s3://$S3_BUCKET/$LAMBDA_FUNCTION/environments/prod/versions/$VERSION/"
        
        if [[ "$FORCE_DEPLOY" == "true" ]]; then
          echo "🚨 Force deployment enabled in PRODUCTION"
          echo "::warning::Force deployment bypasses all safety checks"
          echo "::warning::This should only be used for emergency hotfixes"
          echo "can-deploy=true" >> $GITHUB_OUTPUT
        elif aws s3 ls "$PROD_S3_PATH" > /dev/null 2>&1; then
          echo "❌ Version conflict in PRODUCTION environment"
          echo "::error::Version $VERSION already exists in production"
          echo "::error::Production requires unique versions for audit and rollback"
          echo "::error::Resolution options:"
          echo "::error::  1. Increment version (recommended)"
          
          if [[ "$VERSION" =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
            SUGGESTED_PATCH=$(echo $VERSION | awk -F. '{$NF = $NF + 1; print}' OFS=.)
            echo "::error::     Next patch: $SUGGESTED_PATCH"
          fi
          
          echo "::error::  2. Use force-deploy: true (emergency only)"
          echo "can-deploy=false" >> $GITHUB_OUTPUT
          exit 1
        else
          echo "✅ Version $VERSION is new in PRODUCTION environment"
          echo "can-deploy=true" >> $GITHUB_OUTPUT
        fi
        ;;
        
      *)
        echo "🤔 Unknown Environment: $ENV (applying production policies)"
        echo "::warning::Unknown environment, using strict version checking"
        
        UNKNOWN_S3_PATH="s3://$S3_BUCKET/$LAMBDA_FUNCTION/environments/$ENV/versions/$VERSION/"
        
        if [[ "$FORCE_DEPLOY" == "true" ]]; then
          echo "can-deploy=true" >> $GITHUB_OUTPUT
        elif aws s3 ls "$UNKNOWN_S3_PATH" > /dev/null 2>&1; then
          echo "::error::Version conflict in $ENV environment"
          echo "can-deploy=false" >> $GITHUB_OUTPUT
          exit 1
        else
          echo "can-deploy=true" >> $GITHUB_OUTPUT
        fi
        ;;
    esac
    
    echo ""
    echo "🎯 Version conflict check completed for $ENV environment"

- name: Fixed S3 Upload with Environment Isolation
  id: deploy-to-s3
  if: steps.version-check.outputs.can-deploy == 'true'
  shell: bash
  run: |
    set -e
    
    ENV="${{ steps.determine-env.outputs.environment }}"
    VERSION="${{ steps.get-version.outputs.version }}"
    S3_BUCKET="${{ env.S3_BUCKET_NAME }}"
    LAMBDA_FUNCTION="${{ env.LAMBDA_FUNCTION_NAME }}"
    ARTIFACT_PATH="${{ env.ARTIFACT_PATH }}"
    TIMESTAMP=$(date +%s)
    
    echo "📦 Fixed S3 Upload with Environment Isolation"
    echo "Environment: $ENV"
    echo "Version: $VERSION"
    echo ""
    
    # Environment-specific S3 paths
    case "$ENV" in
      "dev"|"development")
        # Dev: Use timestamp-based paths for rapid iteration
        S3_KEY="$LAMBDA_FUNCTION/environments/dev/deployments/$TIMESTAMP/lambda.zip"
        LATEST_KEY="$LAMBDA_FUNCTION/environments/dev/latest/lambda.zip"
        
        echo "🔧 Dev deployment with timestamp isolation"
        aws s3 cp "$ARTIFACT_PATH" "s3://$S3_BUCKET/$S3_KEY" \
          --metadata "environment=$ENV,version=$VERSION,timestamp=$TIMESTAMP,commit=$(git rev-parse --short HEAD)"
        
        # Update dev latest
        aws s3 cp "$ARTIFACT_PATH" "s3://$S3_BUCKET/$LATEST_KEY" \
          --metadata "environment=$ENV,version=$VERSION,timestamp=$TIMESTAMP"
        ;;
        
      "pre"|"staging"|"test")
        # Pre: Environment-specific versioned paths
        S3_KEY="$LAMBDA_FUNCTION/environments/pre/versions/$VERSION/$LAMBDA_FUNCTION-$VERSION.zip"
        LATEST_KEY="$LAMBDA_FUNCTION/environments/pre/latest/lambda.zip"
        
        echo "🧪 Pre deployment with environment isolation"
        aws s3 cp "$ARTIFACT_PATH" "s3://$S3_BUCKET/$S3_KEY" \
          --metadata "environment=$ENV,version=$VERSION,deployed_at=$(date -u +%Y-%m-%dT%H:%M:%SZ),commit=$(git rev-parse --short HEAD)"
        
        # Update pre latest
        aws s3 cp "$ARTIFACT_PATH" "s3://$S3_BUCKET/$LATEST_KEY" \
          --metadata "environment=$ENV,version=$VERSION"
        ;;
        
      "prod"|"production")
        # Prod: Environment-specific versioned paths with strict metadata
        S3_KEY="$LAMBDA_FUNCTION/environments/prod/versions/$VERSION/$LAMBDA_FUNCTION-$VERSION.zip"
        LATEST_KEY="$LAMBDA_FUNCTION/environments/prod/latest/lambda.zip"
        
        echo "🏭 Prod deployment with strict environment isolation"
        aws s3 cp "$ARTIFACT_PATH" "s3://$S3_BUCKET/$S3_KEY" \
          --metadata "environment=$ENV,version=$VERSION,deployed_at=$(date -u +%Y-%m-%dT%H:%M:%SZ),commit=$(git rev-parse HEAD),branch=$(git rev-parse --abbrev-ref HEAD)"
        
        # Update prod latest
        aws s3 cp "$ARTIFACT_PATH" "s3://$S3_BUCKET/$LATEST_KEY" \
          --metadata "environment=$ENV,version=$VERSION"
        ;;
        
      *)
        # Unknown environment: Use environment-specific path
        S3_KEY="$LAMBDA_FUNCTION/environments/$ENV/versions/$VERSION/$LAMBDA_FUNCTION-$VERSION.zip"
        LATEST_KEY="$LAMBDA_FUNCTION/environments/$ENV/latest/lambda.zip"
        
        echo "🤔 Unknown environment deployment with isolation"
        aws s3 cp "$ARTIFACT_PATH" "s3://$S3_BUCKET/$S3_KEY" \
          --metadata "environment=$ENV,version=$VERSION"
        
        aws s3 cp "$ARTIFACT_PATH" "s3://$S3_BUCKET/$LATEST_KEY" \
          --metadata "environment=$ENV,version=$VERSION"
        ;;
    esac
    
    echo "✅ Package uploaded to s3://$S3_BUCKET/$S3_KEY"
    echo "✅ Latest updated at s3://$S3_BUCKET/$LATEST_KEY"
    
    # Store deployment metadata
    DEPLOYMENT_METADATA="{
      \"environment\": \"$ENV\",
      \"version\": \"$VERSION\",
      \"s3_key\": \"$S3_KEY\",
      \"latest_key\": \"$LATEST_KEY\",
      \"timestamp\": \"$(date -u +%Y-%m-%dT%H:%M:%SZ)\",
      \"commit\": \"$(git rev-parse HEAD)\",
      \"commit_short\": \"$(git rev-parse --short HEAD)\",
      \"branch\": \"$(git rev-parse --abbrev-ref HEAD)\",
      \"artifact_size\": \"$(stat -c%s "$ARTIFACT_PATH" 2>/dev/null || echo 0)\"
    }"
    
    # Upload deployment metadata for audit trail
    echo "$DEPLOYMENT_METADATA" > deployment-metadata.json
    METADATA_KEY="$LAMBDA_FUNCTION/environments/$ENV/deployments/metadata/$VERSION-$(date +%s).json"
    aws s3 cp deployment-metadata.json "s3://$S3_BUCKET/$METADATA_KEY" || echo "::warning::Failed to upload metadata (non-critical)"
    
    # Set outputs
    echo "s3-key=$S3_KEY" >> $GITHUB_OUTPUT
    echo "latest-key=$LATEST_KEY" >> $GITHUB_OUTPUT
    echo "s3-location=s3://$S3_BUCKET/$S3_KEY" >> $GITHUB_OUTPUT
    echo "deployment-metadata=$DEPLOYMENT_METADATA" >> $GITHUB_OUTPUT
    
    echo ""
    echo "🎯 S3 upload completed with environment isolation"

- name: Fixed Lambda Update
  shell: bash
  run: |
    set -e
    
    S3_BUCKET="${{ env.S3_BUCKET_NAME }}"
    LAMBDA_FUNCTION="${{ env.LAMBDA_FUNCTION_NAME }}"
    S3_KEY="${{ steps.deploy-to-s3.outputs.s3-key }}"
    ENV="${{ steps.determine-env.outputs.environment }}"
    VERSION="${{ steps.get-version.outputs.version }}"
    
    echo "🔄 Updating Lambda function with environment-specific artifact"
    echo "S3 Location: s3://$S3_BUCKET/$S3_KEY"
    
    # Update Lambda function with retry logic
    RETRY_COUNT=0
    MAX_RETRIES=3
    
    while [[ $RETRY_COUNT -lt $MAX_RETRIES ]]; do
      if aws lambda update-function-code \
        --function-name "$LAMBDA_FUNCTION" \
        --s3-bucket "$S3_BUCKET" \
        --s3-key "$S3_KEY" \
        --publish > /tmp/lambda-update.json; then
        
        # Get deployment info
        LAMBDA_VERSION=$(jq -r '.Version' /tmp/lambda-update.json)
        LAMBDA_SIZE=$(jq -r '.CodeSize' /tmp/lambda-update.json)
        
        # Tag Lambda function with environment and version info
        aws lambda tag-resource \
          --resource "arn:aws:lambda:${AWS_REGION}:$(aws sts get-caller-identity --query Account --output text):function:${LAMBDA_FUNCTION}" \
          --tags "Environment=$ENV,Version=$VERSION,DeployedAt=$(date -u +%Y-%m-%dT%H:%M:%SZ),S3Key=$S3_KEY" \
          2>/dev/null || echo "::warning::Failed to tag Lambda function (non-critical)"
        
        echo "✅ Lambda function updated successfully!"
        echo "  Environment: $ENV"
        echo "  Version: $VERSION"
        echo "  Lambda Version: $LAMBDA_VERSION"
        echo "  Package Size: $(numfmt --to=iec $LAMBDA_SIZE)"
        echo "  S3 Location: s3://$S3_BUCKET/$S3_KEY"
        
        break
      else
        ((RETRY_COUNT++))
        if [[ $RETRY_COUNT -eq $MAX_RETRIES ]]; then
          echo "::error::Failed to update Lambda function after $MAX_RETRIES attempts"
          exit 1
        else
          echo "::warning::Lambda update attempt $RETRY_COUNT failed, retrying..."
          sleep 5
        fi
      fi
    done

# Fixed rollback logic with environment isolation
- name: Fixed Rollback Logic
  if: steps.deployment-mode.outputs.deployment-mode == 'rollback'
  shell: bash
  run: |
    set -e
    
    ENV="${{ steps.determine-env.outputs.environment }}"
    ROLLBACK_VERSION="${{ steps.deployment-mode.outputs.target-version }}"
    S3_BUCKET="${{ env.S3_BUCKET_NAME }}"
    LAMBDA_FUNCTION="${{ env.LAMBDA_FUNCTION_NAME }}"
    
    # Normalize version
    NORMALIZED_VERSION=$(echo "$ROLLBACK_VERSION" | sed 's/^v//')
    
    echo "🔄 Fixed Rollback with Environment Isolation"
    echo "Environment: $ENV"
    echo "Rollback Version: $NORMALIZED_VERSION"
    
    # Environment-specific rollback S3 path
    case "$ENV" in
      "dev"|"development")
        echo "::error::Rollback not supported for dev environment (uses timestamps)"
        echo "::error::Dev deployments use timestamp-based paths, not versions"
        exit 1
        ;;
      "pre"|"staging"|"test")
        S3_KEY="$LAMBDA_FUNCTION/environments/pre/versions/$NORMALIZED_VERSION/$LAMBDA_FUNCTION-$NORMALIZED_VERSION.zip"
        ;;
      "prod"|"production")
        S3_KEY="$LAMBDA_FUNCTION/environments/prod/versions/$NORMALIZED_VERSION/$LAMBDA_FUNCTION-$NORMALIZED_VERSION.zip"
        ;;
      *)
        S3_KEY="$LAMBDA_FUNCTION/environments/$ENV/versions/$NORMALIZED_VERSION/$LAMBDA_FUNCTION-$NORMALIZED_VERSION.zip"
        ;;
    esac
    
    echo "🔍 Looking for rollback artifact in $ENV environment"
    echo "S3 Location: s3://$S3_BUCKET/$S3_KEY"
    
    # Check if rollback version exists in the specific environment
    if ! aws s3api head-object --bucket "$S3_BUCKET" --key "$S3_KEY" > /dev/null 2>&1; then
      echo "::error::Rollback version $NORMALIZED_VERSION not found in $ENV environment"
      echo "::error::S3 location: s3://$S3_BUCKET/$S3_KEY"
      echo "::error::Available versions in $ENV:"
      aws s3 ls "s3://$S3_BUCKET/$LAMBDA_FUNCTION/environments/$ENV/versions/" --recursive | grep "\.zip$" | head -10 || echo "No versions found"
      exit 1
    fi
    
    # Perform rollback
    echo "🔄 Rolling back Lambda function to $NORMALIZED_VERSION in $ENV environment"
    if aws lambda update-function-code \
      --function-name "$LAMBDA_FUNCTION" \
      --s3-bucket "$S3_BUCKET" \
      --s3-key "$S3_KEY" \
      --publish > /tmp/rollback-update.json; then
      
      LAMBDA_VERSION=$(jq -r '.Version' /tmp/rollback-update.json)
      LAMBDA_SIZE=$(jq -r '.CodeSize' /tmp/rollback-update.json)
      
      # Tag rollback
      aws lambda tag-resource \
        --resource "arn:aws:lambda:${AWS_REGION}:$(aws sts get-caller-identity --query Account --output text):function:${LAMBDA_FUNCTION}" \
        --tags "Environment=$ENV,Version=$NORMALIZED_VERSION,RolledBackAt=$(date -u +%Y-%m-%dT%H:%M:%SZ),S3Key=$S3_KEY" \
        2>/dev/null || echo "::warning::Failed to tag rollback (non-critical)"
      
      echo "✅ Rollback completed successfully!"
      echo "  Environment: $ENV"
      echo "  Rolled back to: $NORMALIZED_VERSION"
      echo "  Lambda Version: $LAMBDA_VERSION"
      echo "  Package Size: $(numfmt --to=iec $LAMBDA_SIZE)"
      echo "  S3 Location: s3://$S3_BUCKET/$S3_KEY"
    else
      echo "::error::Failed to rollback Lambda function"
      exit 1
    fi

# Documentation of new S3 structure
- name: Document New S3 Structure
  shell: bash
  run: |
    echo "📋 New S3 Structure with Environment Isolation:"
    echo ""
    echo "s3://${{ env.S3_BUCKET_NAME }}/"
    echo "├── ${{ env.LAMBDA_FUNCTION_NAME }}/"
    echo "│   ├── environments/"
    echo "│   │   ├── dev/"
    echo "│   │   │   ├── deployments/"
    echo "│   │   │   │   ├── 1692123456/lambda.zip"
    echo "│   │   │   │   └── 1692123789/lambda.zip"
    echo "│   │   │   └── latest/lambda.zip"
    echo "│   │   ├── pre/"
    echo "│   │   │   ├── versions/"
    echo "│   │   │   │   ├── 1.0.0/function-1.0.0.zip"
    echo "│   │   │   │   └── 1.0.1/function-1.0.1.zip"
    echo "│   │   │   └── latest/lambda.zip"
    echo "│   │   └── prod/"
    echo "│   │       ├── versions/"
    echo "│   │       │   ├── 1.0.0/function-1.0.0.zip"
    echo "│   │       │   └── 1.0.1/function-1.0.1.zip"
    echo "│   │       └── latest/lambda.zip"
    echo "│   └── metadata/"
    echo "│       └── deployments/"
    echo ""
    echo "✅ Benefits:"
    echo "  - Complete environment isolation"
    echo "  - Version check paths match upload paths"
    echo "  - No cross-environment overwrites"
    echo "  - Environment-specific rollback support"
    echo "  - Clear audit trail per environment"
